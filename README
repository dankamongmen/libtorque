============================================
libtorque, a multithreaded I/O event library
Copyright © 2009 Nick Black <dank@qemfd.net>
Render this document with fixed-width fonts.
============================================

Wiki - http://dank.qemfd.net/dankwiki/index.php/Libtorque
Mailing list - http://groups.google.com/group/libtorque-devel
GitHub project page - http://github.com/dankamongmen/libtorque
Primary git repository - git://github.com/dankamongmen/libtorque.git
Bugzilla - http://dank.qemfd.net/bugzilla/buglist.cgi?product=libtorque
___________________________________________________________________
888 ,e, 888        d8           "...tear the roof off the sucka..."
888  "  888 88e   d88    e88 88e  888,8,  e88 888 8888 8888  ,e e,
888 888 888 888b d88888 d888 888b 888 "  d888 888 8888 8888 d88 88b
888 888 888 888P  888   Y888 888P 888    Y888 888 Y888 888P 888   ,
888 888 888 88"   888    "88 88"  888     "88 888  "88 88"   "YeeP"
_____________________________________________ 888 _________________
continuation-based unix i/o for manycore numa\888/© nick black 2009

----------------------------------------------------------------libtorque-----
-=+ I. History and licensing +=-
----------------------------------------------------------------libtorque-----

libtorque was conceived as a project for Professor Richard Vuduc's Fall 2009
"CSE 6230: Tools and Applications for High Performance Computing" at the
Georgia Institute of Technology. The original proposal for libtorque is
available at:

	http://dank.qemfd.net/tabpower/cse6230proposal.pdf

libtorque is licensed under version 2 of the Apache License:

	http://www.apache.org/licenses/LICENSE-2.0.html

A copy can be found in the toplevel file LICENSE.

Development of libtorque would have been impossible without the extraordinary
grace, patience and benevolence of management at McAfee Research, particularly
Dmitri Alperovitch and Dr. Sven Krasser.

----------------------------------------------------------------libtorque-----
-=+ II. Minimum requirements +=-
----------------------------------------------------------------libtorque-----

--architecture requirements---------------------------------------------------

Only x86 processors with the CPUID instruction are currently supported (most
everything from the Pentium Pro onwards). Further hardware support is intended.

--operating system requirements-----------------------------------------------

libtorque has been tested on Linux (version 2.6.31), and FreeBSD (version 7.1).
It might work on earlier versions of Linux. Support for other operating
systems, and earlier versions, is intended.

--compiler requirements-------------------------------------------------------

libtorque does not employ the GNU autoconf tools, but is reliant upon GNU Make
and the GNU Compiler Collection. gcc is tracked quite closely, and only recent
versions might be supported at any time; 4.3 is the minimum gcc version
explicitly supported or recommended.

--libc/pthreads requirements--------------------------------------------------

On Linux, the GNU C Library is required, using the NPTL threading
implementation. Version 2.9 has been tested. NPTL is the default on 2.6 kernels
since GNU libc 2.3.2.

On FreeBSD, only the libthr threading implementation is explicitly supported or
recommended (this is the default in FreeBSD 7). If rebuilding world, ensure
NO_LIBTHR is not active in make.conf. If using another pthread library as the
default, bind libpthread references to libthr via the following entries in
/etc/libmap.conf:

	libpthread.so.2         libthr.so.2
	libpthread.so           libthr.so

If using a 32-bit version of the library on a 64-bit system, place these same
lines in /etc/libmap32.conf. The mapping may be restricted to libtorque if
necessary (this author recommends general use of the libthr implementation).

--cpuset requirements---------------------------------------------------------

On FreeBSD, the native code added during 7.1 development is used.

On Linux, administrative support for cpusets requires CONFIG_CPUSET to be
enabled in the kernel (if cpuset partitioning is in effect, a "cpuset" or
"cgroups" filesystem will be mounted on /dev/cpuset). Affinities can and will
still be used by libtorque without this support, but it will be difficult to
partition processing and memory elements up among processes. Affinities have
been part of Linux since 2.5.8. See the Linux kernel's
Documentation/cpusets.txt and libtorque bug #14 
(http://dank.qemfd.net/bugzilla/show_bug.cgi?id=14) for more info. If cgroups
are used, you likely also want CONFIG_GROUP_SCHED.

The SGI libcpuset library (http://oss.sgi.com/projects/cpusets/) was evaluated,
but I decided against it due to stability, portability and maintenance issues.
Version 1.0 was tested.

--numa requirements---------------------------------------------------------

On Linux, the libNUMA library (http://oss.sgi.com/projects/libnuma/) is used.
Version 2.0.3 has been tested. CONFIG_NUMA must be enabled in the kernel; if
NUMA is properly supported, devices/system/node* directories will be
present in mounted sysfs filesystems. FreeBSD does not, to my knowledge, expose
NUMA details as of 7.2.

--doc requirements----------------------------------------------------------

Building the documentation (distributed in Docbook XML) requires xsltproc
(part of the GNOME project's libxslt). A network connection is required if
the Docbook DTD's and XSL stylesheets are not installed; building the
documentation will be much faster with local copies. Install:

 - docbook-xml, docbook-xsl, xsltproc (Debian)
 - textproc/docbook-xml, textproc/docbook-xsl, textproc/xsltproc (FreeBSD)

--misc requirements---------------------------------------------------------

Exuberant Ctags are required to build the tagfile. Install:

 - devel/ctags (FreeBSD)
 - exuberant-ctags (Debian)

----------------------------------------------------------------libtorque-----
-=+ III. Building libtorque +=-
----------------------------------------------------------------libtorque-----

Environment variables can affect the build by overriding defaults:

 PREFIX (Installation prefix. Default: /usr/local)
 DOCPREFIX (Doc installation prefix. Default: /usr/local/share (Linux),
						/usr/local (FreeBSD))
 CC (C compiler executable. Default: gcc-4.4 (Linux), gcc44 (FreeBSD))
 TAGBIN (Source tag generator. Default: exctags if on path, otherwise ctags)
 XSLTPROC (XSL processor. Default: xsltproc)
 MARCH/MTUNE (Code generation settings. See below)

Policy decisions can be made by defining certain variables:

 LIBTORQUE_WITHOUT_ADNS (if defined, do not build in GNU adns support)
 LIBTORQUE_WITHOUT_OPENSSL (if defined, do not build in OpenSSL support)

Changing environment variables ought be followed by the 'clean' target;
this is one of the very few times the 'clean' target must be used.

By default, libtorque is built optimizing for the buildhost's µ-architecture
and ISA, using gcc 4.3's "native" option to -march and -mtune. If you don't
have gcc 4.3 or greater, you'll need to define appropriate march and mtune
values for your system (see gcc's "Submodel Options" info page). Libraries
intended to be run on arbitrary x86 hardware must be built with MARCH 
explicitly defined as "generic", and MTUNE unset. The resulting libraries will
be wretchedly suboptimal on the vast majority of x86 processors.

From the toplevel, invoke GNU make. On Linux, 'make' is almost always GNU make.
On FreeBSD, the devel/gmake Port supplies GNU make as 'gmake'. This will build
the libtorque library, and run the supplied unit tests. Unit test failures are
promoted to full build failures. The install target can then be run to install
the library.

Note: The 'install' target depends on unit testing targets, and thus will not
install a known-unsafe library. This might be undesirable when hacking on the
library, and testing with another application. The 'unsafe-install' target is
provided to facilitate such operation. Its use is not typically recommended.

The 'deinstall' target will remove the files installed by that version of
libtorque (it cannot remove files installed only by previous versions). Since
libtorque does not install any active configuration files, use of 'deinstall'
is thus recommended prior to updating and rebuilding libtorque. Non-existence
of files is not considered an error by the 'deinstall' target.

libtorque can be brought up to date via 'git pull'. The 'clean' target ought
never be necessary to run, save when hacking on the build process itself (or
changing build parameters, as noted above), or after source files are removed.

----------------------------------------------------------------libtorque-----
-=+ IV. Design Issues +=-
----------------------------------------------------------------libtorque-----

- Execution unit detection, differentiation, and effective use. This might
  have to deal with symmetric multiprocessing, one or many multicore packages,
  simultaneous multithreading (ie HyperThreading), heterogenous cores, limited
  cpusets, and processors which are removed from or added to the workset at
  runtime. Power management capabilities, functional units, memory and I/O
  paths and interconnection properties all play roles in data placement and
  event scheduling. Instruction set details ought not matter so much.

  libtorque will initially operate as the sole user of any processing units it
  is allocated; consideration of other processes, if it exists, is incidental.
  Later, this might change. We might support prioritizing within a cpuset, so
  that for instance two libtorque programs can share the entirety of a cpuset,
  but stomp on each other minimally. It would of course generally be best to
  combine these various components into a single libtorque program.

- Memory detection, differentiation and effective use. This might have to deal
  with unified vs split caches, n-way associativities, line sizes, total store
  sizes, page sizes and types, prefetching, eviction policies, DMA into DRAM
  or even cache SRAM, multiprocessor coherence and sharing, inclusive and
  exclusive levels, bank count, and TLB sizes. It is unexpected that libtorque
  will take into consideration memory pipelining, writethrough vs writeback,
  memory bandwidth, or absolute latency.

  libtorque will, for instance, want to generally schedule two functionally
  pipelined gyres on a shared die, whereas functionally parallel codes might be
  usually scheduled irrespective of die-sharing. Stacks can freely alias one
  another across exclusive, independent caches, but ought not relative to a
  shared cache. Meanwhile, multiple states scheduled on a given thread ought
  not be aliasing. These issues combine in complex, interesting ways as the
  eventspace becomes irregular, and states must be moved among processors (for
  instance, select a processor serving no aliasing states if one's available).

- Not only event-handling, but also event receipt must be scheduled. Any given
  set of threads can invoke event discovery, on shared or distinct sets of
  events, where shared events could employ shared or distinct kernel-side event
  sets. Multiple listeners on an event means more flexibility, but also more
  communication and wasted work; it is likely better to move the event.
  If no more than one thread can wait for an event, and either one-shot
  handling or edge-triggering is used, a majority of locking and possible
  contention can be excised from the core.
