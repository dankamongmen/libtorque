Event Queues and Threads

This document primarily described Linux's epoll(7) I/O event notification
facility as of the 2.6 kernel series. It is believed to largely apply also to
FreeBSD's kqueue(7) mechanism. The information within has been extracted from
documentation, mailing lists, reading source and extensive experimentation.
Little, however, makes up published, official API, and thus some of these
details might change without warning.

1. Details of the Linux epoll(7) implementation
2. Details of the FreeBSD kqueue(7) implementation
3. Functional semantics
4. Performance semantics
5. Non-solutions

-----------------------------------------------------------------------------
1. Details of the Linux epoll(7) implementation (taken from 2.6.32.2):
-----------------------------------------------------------------------------
A struct eventpoll contains, among other things:

 - a spinlock_t, "lock"
 - a struct mutex, "mtx"
 - two wait_queue_head_t's, "wq" and "poll_wait"

sys_epoll_wait() validates input and calls ep_poll() (fs/eventpoll.c). Its
core loop:

 - acquires "lock"
 - if there are no events ready or signals pending:
 -- release "lock", sleep on "wq"
 --- ep_poll_callback() is in charge of waking up "wq"
 --- a timeout is also used (LONG_MAX if we passed timeout < 0)
 -- reacquire "lock", loop to event/signal check
 - release "lock"
 - call ep_send_events()->ep_scan_ready_list() (see below)
 - if we have events ready, pending signals, or the timeout has expired, return
 - otherwise, loop

ep_send_events()->ep_scan_ready_list() is largely linear code:

 - acquires "mtx"
 - acquires "lock"
 - steals the ready list "rdllist" to "txlist"
 - releases "lock"
 - calls ep_send_events_proc() with "txlist"
 - acquires "lock"
 - appends "ovflist" to "rdllist", resets "ovflist"
 - appends "txlist" to "rdllist"
 - if "rdllist" is non-empty, wake up "wq"
 - release "lock"
 - release "mtx" 
 - if "rdllist" is non-empty, wake up "poll_wait"

ep_send_events_proc() iterates over a list of struct epitem objects:

 - if the revent mask matches that requested:
 -- copy the event
 -- if EPOLLONESHOT is set, events &= (EPOLLONESHOT|EPOLLET)
 -- else if EPOLLET is *not* set, add it back to the ready list

"mtx" is held across ep_scan_ready_list() and thus ep_send_events_proc(), even
if EPOLLET is in use (and thus we needn't add events back to the ready list).
See the comment in ep_send_events_proc() about locking out epoll_ctl() callers,
which are directed to "ovflist".

sys_epoll_ctl() validates input, and:

 - acquires "mtx"
 - searches for the fd using ep_find()
 -- EPOLL_CTL_ADD with a present fd generates EEXIST
 -- EPOLL_CTL_DEL and EPOLL_CTL_MOD with a non-present fd generates ENOENT
 - call the appropriate one of ep_insert(), ep_remove(), ep_modify()
 - releases "mtx"

-----------------------------------------------------------------------------
2. Details of the FreeBSD kqueue(7) implementation:
-----------------------------------------------------------------------------

 FIXME

-----------------------------------------------------------------------------
3. Functional semantics
-----------------------------------------------------------------------------
Multiple threads can safely call into event retrieval -- the event queue will
not be corrupted.

Events are retrieved greedily. A thread will grab as many as it indicates
room for.

Multiple threads can safely modify an event queue, event if threads are
retrieving from it -- the event queue will not be corrupted, and threads
sleeping in retrieval will be woken up for new ready events.

Level-triggered events cannot be safely processed by multiple threads
without some kind of extra locking, except in circumstances so rare
(and likely trivial) that they're barely worth accounting for:

 - LT event 1 becomes ready
 - Thread A retrieves LT event 1 instance 1
 - Thread B retrieves LT event 1 instance 2
 - Thread A enters LT event 1 handler
 - Thread B enters LT event 1 handler
 - either contention or race follows

Edge-triggered, auto-renewed events cannot be safely processed by multiple
threads without some kind of extra locking, except when file descriptor
availability suffices to synchronize the event handling. An example of this
would be a callback which simply loops on accept(2) until EAGAIN/EWOULDBLOCK,
possibly performing some MT-safe processing on each new file descriptor (adding
the new fd to the event queue would be fine, since we've already shown event
queue operations to be MT-safe. Otherwise, for instance if reading data from
the fd into an associated buffer:

 - ET event 1 becomes ready
 - Thread A retrieves ET event 1 instance 1
 - Thread B sleeps
 - Thread A enters ET event 1 handler, read(2)ing all available data
 - ET event 1 is automatically rearmed
 - Thread B wakes up, retrieves ET event 1 instance 2
 - Thread B enters ET event 1 handler, read(2)ing all available data
 - ET event 1 is automatically rearmed
 - Thread A enters ET event 1 critical section
 - Thread B enters ET event 1 critical section
 - either contention or race follows

Edge-triggered, one-shot events can be safely processed by multiple threads
so long as they're rearmed only at the end of the handler. They require
more event queue modifications than other solutions (assuming that we always
handle as much data as is provided in any callback -- the edge-triggering
requirement. Callbacks which depend on level-triggered semantics might
perform explicit disabling calls from time to time).

-----------------------------------------------------------------------------
4. Performance semantics
-----------------------------------------------------------------------------
Edge-triggered semantics allow a more efficient internal implementation than
level-triggered semantics.

Modifications and (running) retrievals are serialized by the kernel for
each event queue. As the number of threads per event queue rises, the
expected volume of waiting also increases. A complex feedback system is
likely to emerge if contention ever becomes non-negligible.

-----------------------------------------------------------------------------
5. Non-solutions
-----------------------------------------------------------------------------
Single-threaded retrieval of events into a userspace queue shared among
multiple threads doesn't solve any correctness problems, or meaningfully
reduce locking (unless, possibly, when threads are retrieving less events at
one time than is optimal based on load). The actual work of retrieval (as
opposed to sleeping) is still serialized by the kernel, and must be
performed.
