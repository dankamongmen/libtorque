Termination

Libtorque's interaction with signals, use of multiple threads, and portability
requirements makes termination a somewhat complex affair. Goals include
honoring traditional UNIX idioms, clean handling of external signals, robust
semantics no matter when termination is initiated, flexibility, interoperation
with debuggers and other arbitrary tools, and not allowing termination to slow
down the usual case of event handling.

Details of the POSIX signal/threads model are available at
http://dank.qemfd.net/dankwiki/index.php/Pthreads#Pthreads_signal_model

I. POSIX cancellation unused

POSIX provides both "thread cancellation" and signal handling. libtorque makes
no use of thread cancellation: threads are created with cancellation disabled,
and never enable it. Orderly termination within libtorque makes use of signals.

Justification: we must handle signals as part of our API. It is unsafe to
handle signals (or, for that matter, terminate) while performing arbitrary
event processing, thus we must mask and unmask in a controlled fashion. This
takes time and adds complication. Since we're already doing it for signals,
let's not do it a second time for cancellation.

Downsides: we rely on other threads within the process not to mark signals we
use internally as ignored, since signal handlers are per-process. We further
rely on other threads to keep our termination-initiating signal masked, since
process-directed signals might not otherwise be delivered to libtorque threads.
We can check upon libtorque context initialization that this is the case, but
the calling program (or one of its libraries) might change this later.
